from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import pickle
import hashlib
import logging

# Configure logging
logger = logging.getLogger(__name__)

# Define data structures for messages and compressed contexts
@dataclass
class Message:
    content: str
    metadata: Dict[str, Any]
    role: str = "user"  # Add role field for better context
    timestamp: float = 0.0  # Add timestamp for ordering

@dataclass
class CompressedContext:
    data: bytes
    metadata: Dict[str, Any]
    checksum: str  # Add checksum for data integrity


class MemoryCompressor(ABC):
    """Abstract base class for memory compression implementations."""
    
    @abstractmethod
    def compress(self, context: List[Message]) -> CompressedContext:
        """Compress a list of messages into a compressed context."""
        pass

    @abstractmethod
    def decompress(self, compressed: CompressedContext) -> List[Message]:
        """Decompress a compressed context back into a list of messages."""
        pass

    def get_compression_ratio(self, original_size: int, compressed_size: int) -> float:
        """Calculate compression ratio (compressed/original)."""
        if original_size == 0:
            return 1.0
        return compressed_size / original_size


class NoOpCompressor(MemoryCompressor):
    """Default compressor that passes through data unchanged."""
    
    def compress(self, context: List[Message]) -> CompressedContext:
        # Serialize the list of messages to preserve structure
        serialized = pickle.dumps(context)
        
        # Calculate checksum for integrity
        checksum = hashlib.sha256(serialized).hexdigest()
        
        return CompressedContext(
            data=serialized,
            metadata={"compression_type": "none"},
            checksum=checksum
        )

    def decompress(self, compressed: CompressedContext) -> List[Message]:
        # Verify checksum before decompressing
        try:
            calculated_checksum = hashlib.sha256(compressed.data).hexdigest()
            if calculated_checksum != compressed.checksum:
                raise ValueError("Data integrity check failed: checksum mismatch")
        except Exception as e:
            logger.error(f"Checksum verification failed: {e}")
            raise
        
        # Deserialize back to original structure
        return pickle.loads(compressed.data)


class MelodiCompressor(MemoryCompressor):
    """Stub for MELODI integration - raises NotImplementedError."""
    
    def compress(self, context: List[Message]) -> CompressedContext:
        raise NotImplementedError("MelodiCompressor is not yet implemented")

    def decompress(self, compressed: CompressedContext) -> List[Message]:
        raise NotImplementedError("MelodiCompressor is not yet implemented")


def get_compressor(compressor_type: str = "noop") -> MemoryCompressor:
    """Factory function to get a compressor instance."""
    if compressor_type == "noop":
        return NoOpCompressor()
    elif compressor_type == "melodi":
        return MelodiCompressor()
    else:
        raise ValueError(f"Unknown compressor type: {compressor_type}")