from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import pickle
import hashlib
import logging
import threading
import time

# Configure logging
logger = logging.getLogger(__name__)

# Define data structures for messages and compressed contexts
@dataclass
class Message:
    content: str
    metadata: Dict[str, Any]
    role: str = "user"  # Add role field for better context
    timestamp: float = 0.0  # Add timestamp for ordering

@dataclass
class CompressedContext:
    data: bytes
    metadata: Dict[str, Any]
    checksum: str  # Add checksum for data integrity


class MemoryCompressor(ABC):
    """Abstract base class for memory compression implementations."""
    
    @abstractmethod
    def compress(self, context: List[Message]) -> CompressedContext:
        """Compress a list of messages into a compressed context."""
        pass

    @abstractmethod
    def decompress(self, compressed: CompressedContext) -> List[Message]:
        """Decompress a compressed context back into a list of messages."""
        pass

    def get_compression_ratio(self, original_size: int, compressed_size: int) -> float:
        """Calculate compression ratio (compressed/original)."""
        if original_size == 0:
            return 1.0
        return compressed_size / original_size


class NoOpCompressor(MemoryCompressor):
    """Default compressor that passes through data unchanged."""
    
    def __init__(self):
        self._lock = threading.RLock()  # Reentrant lock for thread safety
        self._compression_stats = {
            'total_compressions': 0,
            'total_decompressions': 0,
            'last_compression_time': 0.0,
            'last_decompression_time': 0.0
        }
    
    def compress(self, context: List[Message]) -> CompressedContext:
        # Serialize the list of messages to preserve structure
        try:
            with self._lock:
                serialized = pickle.dumps(context)
                
                # Calculate checksum for integrity
                checksum = hashlib.sha256(serialized).hexdigest()
                
                # Update stats
                self._compression_stats['total_compressions'] += 1
                self._compression_stats['last_compression_time'] = time.time()
                
        except Exception as e:
            logger.error(f"Serialization failed: {e}")
            raise
        
        return CompressedContext(
            data=serialized,
            metadata={"compression_type": "none"},
            checksum=checksum
        )

    def decompress(self, compressed: CompressedContext) -> List[Message]:
        # Verify checksum before decompressing
        try:
            with self._lock:
                calculated_checksum = hashlib.sha256(compressed.data).hexdigest()
                if calculated_checksum != compressed.checksum:
                    raise ValueError("Data integrity check failed: checksum mismatch")
                
                # Deserialize back to original structure
                result = pickle.loads(compressed.data)
                
                # Update stats
                self._compression_stats['total_decompressions'] += 1
                self._compression_stats['last_decompression_time'] = time.time()
                
                return result
        except Exception as e:
            logger.error(f"Checksum verification failed: {e}")
            raise
    
    def get_stats(self) -> Dict[str, Any]:
        """Get compression statistics."""
        with self._lock:
            return self._compression_stats.copy()
    
    def reset_stats(self):
        """Reset compression statistics."""
        with self._lock:
            self._compression_stats = {
                'total_compressions': 0,
                'total_decompressions': 0,
                'last_compression_time': 0.0,
                'last_decompression_time': 0.0
            }


class MelodiCompressor(MemoryCompressor):
    """Stub for MELODI integration - raises NotImplementedError."""
    
    def compress(self, context: List[Message]) -> CompressedContext:
        raise NotImplementedError("MelodiCompressor is not yet implemented")

    def decompress(self, compressed: CompressedContext) -> List[Message]:
        raise NotImplementedError("MelodiCompressor is not yet implemented")


def get_compressor(compressor_type: str = "noop") -> MemoryCompressor:
    """Factory function to get a compressor instance."""
    if compressor_type == "noop" or compressor_type == "none":
        return NoOpCompressor()
    elif compressor_type == "melodi":
        return MelodiCompressor()
    else:
        raise ValueError(f"Unknown compressor type: {compressor_type}")